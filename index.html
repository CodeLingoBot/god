<!DOCTYPE html>
<html>
	<head>
		<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
		<script src="http://code.jquery.com/jquery-latest.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<style type="text/css">
			.illustration {
				float: right;
			}
		</style>
		<title>Go Database!</title>
	</head>
	<body data-spy="scroll" data-target="#sidebar">
		<div class="row">
			<div id="sidebar" class="span3">
				<ul class="nav nav-list affix">
					<li><a href="#overview">Overview</a></li>
					<li><a href="#namespace">Namespace</a></li>
					<li><a href="#structure">Structure</a></li>
					<li><a href="#setops">Set operations</a></li>
					<li><a href="#persistence">Persistence</a></li>
					<li><a href="#routing">Routing</a></li>
					<li><a href="#responsibility">Responsibility</a></li>
					<li><a href="#redundancy">Redundancy</a></li>
					<li><a href="#timestamps">Timestamps</a></li>
					<li><a href="#synchronization">Synchronization</a></li>
					<li><a href="#cleaning">Cleaning</a></li>
					<li><a href="#migration">Migration</a></li>
				</ul>
			</div>
			<div class="span9">
				<h1>god</h1>
				<h2 id="overview">Overview</h2>
				<p>
				god is a scalable, performant, persistent in memory data structure server. It allows massively distributed applications to update and fetch common data in a structured and sorted format.
				</p>
				<p>
				Its main inspirations are <a href="http://redis.io/">Redis</a> and <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord</a>/<a href="http://pdos.csail.mit.edu/papers/dhash:nsdi/paper.pdf">DHash</a>.
				Like <a href="http://redis.io/">Redis</a> it focuses on performance, ease of use and a small, simple yet powerful feature set, 
				while from the <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord</a>/<a href="http://pdos.csail.mit.edu/papers/dhash:nsdi/paper.pdf">DHash</a> projects it inherits scalability, redundancy and transparent failover behaviour.
				<p>To try it out right now, <code>go get github.com/zond/god</code>, then run <code>server</code>.</p>
				<p>For API documentation, go to <a href="http://go.pkgdoc.org/github.com/zond/god">http://go.pkgdoc.org/github.com/zond/god</a>.</p>
				<p>For the source, go to <a href="https://github.com/zond/god">https://github.com/zond/god</a>.</p>
				<h2 id="namespace">Namespace</h2>
				<h3>Chord circle</h3>
				<object class="illustration" data="chord-circle.svg" type="image/svg+xml"></object>
				<p>The namespace of god, as for the <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord</a> project, is a conceptual circle where each actor, be it database node or data item, has a position. Usually the circle overflows at the maximum value for a selected hash function used to spread keys over the namespace.</p>
				<h3>Murmur</h3>
				<p>The hash function used in god is <a href="http://code.google.com/p/smhasher/wiki/MurmurHash3">MurmurHash3</a>, a fairly new and extremely fast hash function. Unlike other hash functions it makes no cryptographical claims, but focuses solely on speed and distribution.</p>
				<p>god contains a slightly modified (only to let it compile in a C compiler) of the 128 bit, x64 version of <a href="http://code.google.com/p/smhasher/wiki/MurmurHash3">MurmurHash3</a> wrapped in a thin layer of Go.</p>
				<h3>Hashed vs non hashed keys</h3>
				<p>The main reason to hash keys before inserting them into the namespace is to avoid concentrating keys in a part of the circle, to facilitate letting all nodes share as equal an amount of data as possible.</p>
				<p>However, since it could be very useful for users of a database to store ordered data, or to wilfully concentrate certain data on certain parts of the cluster, god does not force the user to hash the keys.</p>
				<p>Instead, the nodes in god are able to migrate along the circle to hand off data to one another when an imbalance is detected.</p>
				<p>This would allow, for example, data for a geographical region to be prefixed with a code, and making data with that prefix go on designated servers placed in the same geographical region. The cluster could also be configured so that all backups for data positioned in one region was positioned in other regions for greated safety in the face of disasters of different kinds.</p>
				<p>Currently there is no option to either limit node migrations (to force nodes in one datacenter to stay in one part of the namespace), or to force backups to live on nodes in other datacenters, but it would be fairly easy, conceptually, to add in a future version if the need was felt.</p>
				<h2 id="structure">Structure</h2>
				<h3>Radix trees</h3>
				<object class="illustration" data="radix-tree.svg" type="image/svg+xml"></object>
				<p>
				To map keys to values, a mapping structure is needed. For infrastructural reasons (<a href="#synchronization">synchronization</a> and <a href="#cleaning">cleaning</a>) as well as for functionality of different kinds, we need a sorted mapping, and it has to be deterministically structured.
				</p>
				<p>
				Radix trees have all these attributes, and are somewhat frugal when it comes to memory consumption due to the common parts of keys only being stored once.
				</p>
				<p>
				In the illustration to the right, nodes only contain the part of their key differing from the key of their parent, and the nodes marked red don't contain data at all but only contain common parts of keys for their children. Note that the root node contains the empty key, and in this case it actually has a value as well.
				</p>
				<h3>Byte values</h3>
				<p>
				All nodes in the main tree can contain byte values, which can be encoded to contain strings, integers, floats or whatever kind of data one wants to store.
				</p>
				<h3>Sub trees</h3>
				<object class="illustration" data="tree-values.svg" type="image/svg+xml"></object>
				<p>
				In addition, since the need for structured data (in the sense that one can sort, paginate, slice and dice it) is one of the things that makes a vanilla key/value store hard to use in many common use cases, each key in a Tree can also contain a separate sub tree.
				</p>
				<p>
				This allows us to, for example, store user metadata in the top level byte values, while storing the set of friends in a sub tree. Then we can easily fetch, slice and store friends without having to reserialize the user data (or even worse, the entire set of friends).
				</p>
				<h3>Mirror trees</h3>
				<object class="illustration" data="mirror-trees.svg" type="image/svg+xml"></object>
				<p>To allow us to sort, paginate, slice and dice the data depending on not only key, but also value, each tree can also be 'mirrored'. This, in essence, means that the tree will contain another tree that is exactly mirroring the state of the first tree, except that the keys of the outer tree is the values of the inner tree and vice versa.<p>
				<p>To avoid colliding keys in the mirror trees, when the several keys in the outer tree have the same values, each key in the mirror tree is appended with the corresponding value. Those appendages are removed, however, when key/value pairs are fetched or sliced from the mirror tree.</p>
				<h2 id="setops">Set operations</h2>
				<h3>Operations</h3>
				<h3>Mergers</h3>
				<h3>Destinations</h3>
				<h2 id="persistence">Persistence</h2>
        <h3>Logfiles</h3>
				<h3>Snapshots</h3>
				<h3>Automatic snapshotting</h3>
				<h2 id="routing">Routing</h2>
				<h3>Notify</h3>
				<h3>Ping</h3>
				<h2 id="responsibility">Responsibility</h2>
        <h3>Successors</h3>
				<h2 id="redundancy">Redundancy</h2>
        <h3>N successive backups</h3>
				<h2 id="timestamps">Timestamps</h2>
				<h3>Zombies</h3>
				<h3>Undone changes</h3>
				<h3>Time network</h3>
				<h2 id="synchronization">Synchronization</h2>
				<h3>Merkle trees</h3>
				<h3>Comparing hashes</h3>
				<h2 id="cleaning">Cleaning</h2>
				<h3>Destructive synchronization</h3>
				<h2 id="migration">Migration</h2>
				<h3>Imbalance</h3>
				<h3>Changing positions</h3>
			</div>
		</div>
	</body>
</html>
