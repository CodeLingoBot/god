<!DOCTYPE html>
<html>
	<head>
		<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
		<script src="js/jquery-latest.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<style type="text/css">
		  img.illustration {
		    width: 50%;
			}
		  .illustration {
		    float: right;
		  }
	          .prettyprint {
		    font-size: xx-small;
		  }
		</style>
		<title>Go Database! Docs</title>
	</head>
	<body data-spy="scroll" data-target="#sidebar">
		<div class="row">
			<div class="span12">
			<ul class="nav nav-tabs">
					<li class="active"><a href="index.html">Usage</a></li>
					<li><a href="architecture.html">Architecture</a></li>
				</ul>
			</div>
		</div>
		<div class="row">
			<div id="sidebar" class="span3">
				<ul class="nav nav-list affix">
					<li><a href="#overview">Overview</a></li>
					<li><a href="#operations">Operations</a></li>
					<li><a href="#clients">Clients</a></li>
					<li><a href="#bytestorage">Storing bytes</a></li>
					<li><a href="#users">Users</a></li>
					<li><a href="#structstorage">Storing structures</a></li>
					<li><a href="#followers">Followers</a></li>
					<li><a href="#friends">Friends</a></li>
					<li><a href="#toplists">Top lists</a></li>
					<li><a href="#relevance">Relevance</a></li>
				</ul>
			</div>
			<div class="span9">
				<h1>Usage</h1>
				<h2 id="overview">Overview</h2>
				<p>
				<i>god</i> is a scalable, performant, persistent in memory data structure server. It allows massively distributed applications to update and fetch common data in a structured and sorted format.
				</p>
				<p>
				Its main inspirations are <a href="http://redis.io/">Redis</a> and <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord</a>/<a href="http://pdos.csail.mit.edu/papers/dhash:nsdi/paper.pdf">DHash</a>.
				Like <a href="http://redis.io/">Redis</a> it focuses on performance, ease of use and a small, simple yet powerful feature set, 
				while from the <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord</a>/<a href="http://pdos.csail.mit.edu/papers/dhash:nsdi/paper.pdf">DHash</a> projects it inherits scalability, redundancy and transparent failover behaviour.
				</p>
				<p>
				This is a usage instruction aiming to be somewhere between example collection and tutorial, targeting developers interested in trying out <i>god</i> as datastore. The example code snippets below are tested against somewhat current versions of Go and node, and should run as is if you provide them their dependencies and run a local <i>god</i> server.
				</p>
				<p>
				To try it out right now, <code>go get github.com/zond/god/god_server</code>, then run <code>god_server</code> and browse to <a href="http://localhost:9192/">http://localhost:9192/</a>.
				</p>
				<p>
				For API documentation, go to <a href="http://go.pkgdoc.org/github.com/zond/god">http://go.pkgdoc.org/github.com/zond/god</a>.
				</p>
				<p>
				For the source, go to <a href="https://github.com/zond/god">https://github.com/zond/god</a>.
				</p>
				<h2 id="operations">Operations</h2>
				<p>
				<i>god</i> is built to be simple to use, and as such has no dependencies for building apart from the Go standard library. For running, all you need is one statically linked binary.
				</p>
				<p>
				If you have a working <a href="http://golang.org/doc/install">Go</a> environment installed (specifically a writable <code>$GOPATH</code>), you just run <code>go get github.com/zond/god/god_server</code>. This will download, compile and install <i>god</i> and all its dependencies. After this you will find <code>god_server</code> in <code>$GOPATH/bin</code>. To start a server, just run <code>god_server -verbose=true</code>. Other option can be listed if you run <code>god_server -help</code>.
				</p>
				<p>
				Since there are a plethora of ways to daemonize such a program, and since Go doesn't currently contain its own way of doing it, daemonizing this binary is left to creative ops people out there.
				</p>
				<p>
				To make your server join an existing cluster/server, just run <code>god_server -joinIp HOST/IP</code>. It will default to using port 9191, but using the switch <code>-port</code> can force it to try another port.
				</p>
				<img class="illustration" src="web-gui.png"></object>
				<p>
				To make it easy to use, <i>god</i> always exports its interface on both Go <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> and HTTP/JSON. The HTTP/JSON interface is always exported on the next port after the main one where the <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> interface is exported. By default this is port 9192. If you started your server by running <code>god_server -verbose=true</code> as suggested above, you will find a small administrative/monitoring tool at <a href="http://localhost:9192">http://localhost:9192</a>.
				</p>
				<p>
				The server only listens to the default network interface for <code>localhost</code> by default. To make it listen to (and advertise itself to the cluster on) another network interface, use the switch <code>-ip HOST/IP</code>.
				</p>
				<h2 id="clients">Clients</h2>
				<p>
				As mentioned there are two APIs for <i>god</i>, <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> and HTTP/JSON.
				</p>
				<p>
				Using the <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> API is as simple as <code>go get github.com/zond/god/client</code>, and then <code>import "github.com/zond/god/client"</code>. See <a href="http://godoc.org/github.com/zond/god/client">http://godoc.org/github.com/zond/god/client</a> for godoc generated documentation.
				</p>
				<p>
				To simplify trying it out from the command line, there is also a command line interface available. To install it, run <code>go get github.com/zond/god/god_cli</code>, and then run <code>god_cli</code>. Documentation for the command format for this tool can be found at <a href="https://github.com/zond/god/tree/master/god_cli">https://github.com/zond/god/tree/master/god_cli</a>.
				</p>
				<p>
				Since the HTTP/JSON API is designed to be as simple as possible to interact with from any type of client system, there isn't really much to say about how to use it. Examples for the different commands found in the web monitor at <a href="http://localhost:9192">http://localhost:9192</a> (if the server is started via <code>god_server</code> with default options) along with the generated documentation at <a href="http://godoc.org/github.com/zond/god/client">http://godoc.org/github.com/zond/god/client</a> are likely the best way to learn and explore.
				</p>
				<p>
				The HTTP/JSON API is slightly less efficient than the <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> API, mainly due to the receiving node having to figure out who is responsible for the operation in the request, something that the native Go client does on its own.
				</p>
				<h2 id="bytestorage">Storing bytes</h2>
				<p>
				The simplest and most obvious way to use <i>god</i> is to store bytes in it. Like all content in <i>god</i> nodes, the bytes you put in the system will be stored in RAM in one or more (if you have a cluster, which is really recommended) servers. To store byte arrays in the database, use the <b>put</b> command, either via <code>client.Conn#Put</code> or <code>POST /rpc/DHash.Put</code>.
				</p>
				<h2 id="users">Users</h2>
				<p>
				A trivial example would be to store application users in <i>god</i>. Here is a bit of example Go code that would store and fetch a user object:
				</p>
				<pre class="prettyprint">
package main

import (
  "encoding/json"
  "fmt"
  "github.com/zond/god/client"
  "github.com/zond/god/murmur"
)

type User struct {
  Email    string
  Password string
  Name     string
}

func main() {
  conn := client.MustConn("localhost:9191")
  user := User{
    Email:    "mail@domain.tld",
    Password: "so secret",
    Name:     "john doe",
  }
  if bytes, err := json.Marshal(user); err != nil {
    panic(err)
  } else {
    conn.Put(murmur.HashString(user.Email), bytes)
  }
  data, _ := conn.Get(murmur.HashString(user.Email))
  var found User
  if err := json.Unmarshal(data, &found); err != nil {
    panic(err)
  }
  fmt.Printf("stored and found %+v\n", found)
}

// output: stored and found {Email:mail@domain.tld Password:so secret Name:john doe}

				</pre>
				<p>
				And here is a bit of node compatible JavaScript doing the same thing against the HTTP/JSON API:
				</p>
				<pre class="prettyprint">
var http = require('http');

function rpc(endpoint, params, callback) {
  var data = '';
  var content = JSON.stringify(params);
  var req = http.request({
    hostname: 'localhost',
    port: 9192,
    headers: {
      'Content-Length': content.length,
      'Accept': 'application/json',
    },
    path: '/rpc/DHash.' + endpoint,
    method: 'POST',
  }, function(res) {
    res.setEncoding('utf8');
    res.on('data', function(d) {
      data += d;
    });
    res.on('end', function() {
      callback(JSON.parse(data));
    });
    res.on('close', function() {
      callback(JSON.parse(data));
    });
  });
  req.on('error', function(e) {
    console.log('problem with request: ' + e.message);
  });
  req.write(content);
  req.end();
};

var user = {
  email: 'mail@domain.tld',
  password: 'so secret',
  name: 'john doe',
};

rpc('Put', { 
  Key: new Buffer(user.email).toString('base64'),
  Value: new Buffer(JSON.stringify(user)).toString('base64'),
}, function() {
  rpc('Get', { Key: new Buffer(user.email).toString('base64') }, function(data) {
    console.log('stored and found', JSON.parse(new Buffer(data.Value, 'base64').toString('utf-8')));
  });
});
// output: stored and found { email: 'mail@domain.tld',
// output: password: 'so secret',
// output: name: 'john doe' }

				</pre>
				<h2 id="structstorage">Storing structures</h2>
				<p>
				To experience the real power of <i>god</i>, one really has to use it to store data structures. The data structures in <i>god</i> are themselves key/value stores with unique keys and sorted on keys in byte order.
				</p>
				<p>
				Since they are stored not as serialized values under their keys, but as individual tree structures they can be used to store large amounts of data in a structured fashion, by using the keys of byte values and structures (tree values) to relate them to each other.
				</p>
				<p>
				To further make use of the efficient modification, sorting and lookup properties of these sub trees they can be both 'mirrored' to allow sorting on their values as well as keys and used in various set operations to analyze them in a more algorithmic fashion.
	</p>
				<h2 id="followers">Followers</h2>
				<p>
				The simplest way to store structured data in <i>god</i> is to just dump it into a sub tree as is. Here is a bit of example Go code that would modify and query the followers of a user:
				</p>
				<pre class="prettyprint">
package main

import (
  "fmt"
  "github.com/zond/god/client"
)

func main() {
  conn := client.MustConn("localhost:9191")
  key := []byte("mail@domain.tld/followers")
  conn.SubPut(key, []byte("follower1@domain.tld"), nil)
  conn.SubPut(key, []byte("follower2@domain.tld"), nil)
  conn.SubPut(key, []byte("follower3@domain.tld"), nil)
  fmt.Printf("my first follower is %+v\n", string(conn.SliceLen(key, nil, true, 1)[0].Key))
  last2 := conn.ReverseSliceLen(key, nil, true, 2)
  fmt.Printf("my last two followers are %+v and %+v\n", string(last2[1].Key), string(last2[0].Key))
}

// output: my first follower is follower1@domain.tld
// output: my last two followers are user2@domain.tld and user3@domain.tld

				</pre>
				<p>
				And here is a bit of nody JavaScript doing the same thing against the HTTP/JSON API:
				</p>
				<pre class="prettyprint">
var http = require('http');

function rpc(endpoint, params, callback) {
  var data = '';
  var content = JSON.stringify(params);
  var req = http.request({
    hostname: 'localhost',
    port: 9192,
    headers: {
      'Content-Length': content.length,
      'Accept': 'application/json',
    },
    path: '/rpc/DHash.' + endpoint,
    method: 'POST',
  }, function(res) {
    res.setEncoding('utf8');
    res.on('data', function(d) {
      data += d;
    });
    res.on('end', function() {
      callback(JSON.parse(data));
    });
    res.on('close', function() {
      callback(JSON.parse(data));
    });
  });
  req.on('error', function(e) {
    console.log('problem with request: ' + e.message);
  });
  req.write(content);
  req.end();
};

function after(n, callback) {
  var count = n;
  return function() {
    count--;
    if (count == 0) {
      callback();
    }
  }
}

var key = new Buffer("mail@domain.tld/followers").toString('base64')
var followers = ["follower1@domain.tld", "follower2@domain.tld", "follower3@domain.tld"];
var cb = after(followers.length, function() {
  rpc('SliceLen', {
    Key: key,
    Len: 1,
  }, function(data) {
    console.log('my first follower is', new Buffer(data[0].Key, 'base64').toString('utf-8'));
    rpc('ReverseSliceLen', {
      Key: key,
      Len: 2,
    }, function(data) {
      console.log('my last two followers are', new Buffer(data[1].Key, 'base64').toString('utf-8'), 'and', new Buffer(data[0].Key, 'base64').toString('utf-8'));
    });
  });
});
followers.map(function(follower) {
  rpc('SubPut', {
    Key: key,
    SubKey: new Buffer(follower).toString('base64'),
  }, cb);
});
// output: my first follower is follower1@domain.tld
// output: my last two followers are user2@domain.tld and user3@domain.tld

				</pre>
				<h2 id="friends">Friends</h2>
				<p>
				One simple way to use the set operation support in god would be to intersect followers and followees to produce the users who are both. Below follows a bit of Go code that would produce these users, let us call them friends:
				</p>
				<pre class="prettyprint">
package main

import (
  "fmt"
  "github.com/zond/god/client"
  "github.com/zond/god/setop"
)

func main() {
  conn := client.MustConn("localhost:9191")
  followersKey := []byte("mail@domain.tld/followers")
  followeesKey := []byte("mail@domain.tld/followees")
  conn.SubPut(followersKey, []byte("user1@domain.tld"), nil)
  conn.SubPut(followersKey, []byte("user2@domain.tld"), nil)
  conn.SubPut(followersKey, []byte("user3@domain.tld"), nil)
  conn.SubPut(followeesKey, []byte("user3@domain.tld"), nil)
  conn.SubPut(followeesKey, []byte("user4@domain.tld"), nil)
  for _, friend := range conn.SetExpression(setop.SetExpression{
    Code: fmt.Sprintf("(I %v %v)", string(followersKey), string(followeesKey)),
  }) {
    fmt.Println(string(friend.Key))
  }
}

// output: user3@domain.tld

				</pre>
				<p>
				To do the same thing using node, you can run:
				</p>
				<pre class="prettyprint">
var http = require('http');

function rpc(endpoint, params, callback) {
  var data = '';
  var content = JSON.stringify(params);
  var req = http.request({
    hostname: 'localhost',
    port: 9192,
    headers: {
      'Content-Length': content.length,
      'Accept': 'application/json',
    },
    path: '/rpc/DHash.' + endpoint,
    method: 'POST',
  }, function(res) {
    res.setEncoding('utf8');
    res.on('data', function(d) {
      data += d;
    });
    res.on('end', function() {
      callback(JSON.parse(data));
    });
    res.on('close', function() {
      callback(JSON.parse(data));
    });
  });
  req.on('error', function(e) {
    console.log('problem with request: ' + e.message);
  });
  req.write(content);
  req.end();
};

function after(n, callback) {
  var count = n;
  return function() {
    count--;
    if (count == 0) {
      callback();
    }
  }
}

var followers_key = new Buffer("mail@domain.tld/followers").toString('base64')
var followees_key = new Buffer("mail@domain.tld/followees").toString('base64')
var followers = ["user1@domain.tld", "user2@domain.tld", "user3@domain.tld"];
var followees = ["user3@domain.tld", "user4@domain.tld"];
var cb = after(followers.length + followees.length, function() {
  rpc('SetExpression', {
    Code: '(I ' + new Buffer(followers_key, 'base64').toString('utf-8') + ' ' + new Buffer(followees_key, 'base64').toString('utf-8') + ')',
  }, function(data) {
    data.map(function(friend) {
      console.log(new Buffer(friend.Key, 'base64').toString('utf-8'));
    });
  });
});
followers.map(function(follower) {
  rpc('SubPut', {
    Key: followers_key,
    SubKey: new Buffer(follower).toString('base64'),
  }, cb);
});
followees.map(function(followee) {
  rpc('SubPut', {
    Key: followees_key,
    SubKey: new Buffer(followee).toString('base64'),
  }, cb);
});
// output: user3@domain.tld

				</pre>
				<h2 id="toplists">Top lists</h2>
				<p>
				The tree mirroring capabilities of <i>god</i> lets you sort a mapping on both key and value, by keeping a <i>mirrored</i> version of the main tree, with key and value reversed. This is quite costly, as it has to update the mirrored tree for each update of the main tree, but it lets you do things like keeping a running top list of the highest scoring players of your fancy multi player game. Here is some Go code to do that:
				</p>
				<pre class="prettyprint">
package main

import (
  "fmt"
  "github.com/zond/god/client"
  "github.com/zond/god/common"
)

func main() {
  conn := client.MustConn("localhost:9191")
  key := []byte("score_by_email")
  conn.SubAddConfiguration(key, "mirrored", "yes")
  conn.SubPut(key, []byte("mail1@domain.tld"), common.EncodeInt64(414))
  conn.SubPut(key, []byte("mail2@domain.tld"), common.EncodeInt64(12))
  conn.SubPut(key, []byte("mail3@domain.tld"), common.EncodeInt64(9912))
  conn.SubPut(key, []byte("mail4@domain.tld"), common.EncodeInt64(33))
  conn.SubPut(key, []byte("mail5@domain.tld"), common.EncodeInt64(511))
  conn.SubPut(key, []byte("mail6@domain.tld"), common.EncodeInt64(4512))
  conn.SubPut(key, []byte("mail7@domain.tld"), common.EncodeInt64(1023))
  conn.SubPut(key, []byte("mail8@domain.tld"), common.EncodeInt64(121))
  fmt.Println("top three scores:")
  for index, user := range conn.MirrorReverseSliceLen(key, nil, true, 3) {
    fmt.Println(index, string(user.Value), common.MustDecodeInt64(user.Key))
  }
}

// output: top three scores:
// output: 0 mail3@domain.tld 9912
// output: 1 mail6@domain.tld 4512
// output: 2 mail7@domain.tld 1023

				</pre>
				<p>
				And the corresponding node code:
				</p>
				<pre class="prettyprint">
var http = require('http');

function rpc(endpoint, params, callback) {
  var data = '';
  var content = JSON.stringify(params);
  var req = http.request({
    hostname: 'localhost',
    port: 9192,
    headers: {
      'Content-Length': content.length,
      'Accept': 'application/json',
    },
    path: '/rpc/DHash.' + endpoint,
    method: 'POST',
  }, function(res) {
    res.setEncoding('utf8');
    res.on('data', function(d) {
      data += d;
    });
    res.on('end', function() {
      callback(JSON.parse(data));
    });
    res.on('close', function() {
      callback(JSON.parse(data));
    });
  });
  req.on('error', function(e) {
    console.log('problem with request: ' + e.message);
  });
  req.write(content);
  req.end();
};

function after(n, callback) {
  var count = n;
  return function() {
    count--;
    if (count == 0) {
      callback();
    }
  }
};

function i2b(i) {
  var b = new Buffer(4);
  b.writeInt32BE(i, 0);
  return b.toString('base64');
};

function b2i(b) {
  var b = new Buffer(b, 'base64');
  return b.readInt32BE(0);
};

var key = new Buffer("score_by_email").toString('base64')
var scores = {
  "mail1@domain.tld": i2b(1234),
  "mail2@domain.tld": i2b(3),
  "mail3@domain.tld": i2b(61),
  "mail4@domain.tld": i2b(1121),
  "mail5@domain.tld": i2b(9192),
  "mail6@domain.tld": i2b(5123),
  "mail7@domain.tld": i2b(44),
  "mail8@domain.tld": i2b(6),
};
var cb = after(9, function() {
  rpc('MirrorReverseSliceLen', {
    Key: key,
    Len: 3,
  }, function(data) {
    console.log("top three scores");
    data.map(function(score) {
      console.log(new Buffer(score.Value, 'base64').toString('utf-8'), b2i(score.Key));
    });
  });
});
rpc('SubAddConfiguration', {
  Key: 'mirrored',
  Value: 'yes',
}, cb);
for (var email in scores) {
  rpc('SubPut', {
    Key: key,
    SubKey: new Buffer(email).toString('base64'),
    Value: scores[email],
  }, cb);
}
// output: top three scores
// output: mail5@domain.tld 9192
// output: mail6@domain.tld 5123
// output: mail1@domain.tld 1234

				</pre>
				<h2 id="relevance">Relevance</h2>
				<p>
				Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
				</p>
			      </div>
			    </div>
			  </body>
			</html>
