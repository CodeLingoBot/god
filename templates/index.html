<!DOCTYPE html>
<html>
	<head>
		<link href="css/bootstrap.min.css" rel="stylesheet" media="screen">
		<script src="js/jquery-latest.js"></script>
		<script src="js/bootstrap.min.js"></script>
		<style type="text/css">
			img.illustration {
				width: 50%;
			}
			.illustration {
				float: right;
			}
			.prettyprint {
			  font-size: x-small;
			}
		</style>
		<title>Go Database! Docs</title>
	</head>
	<body data-spy="scroll" data-target="#sidebar">
		<div class="row">
			<div class="span12">
			<ul class="nav nav-tabs">
					<li class="active"><a href="index.html">Usage</a></li>
					<li><a href="architecture.html">Architecture</a></li>
				</ul>
			</div>
		</div>
		<div class="row">
			<div id="sidebar" class="span3">
				<ul class="nav nav-list affix">
					<li><a href="#overview">Overview</a></li>
					<li><a href="#operations">Operations</a></li>
					<li><a href="#clients">Clients</a></li>
					<li><a href="#bytestorage">Storing bytes</a></li>
					<li><a href="#users">Users</a></li>
					<li><a href="#structstorage">Storing structures</a></li>
					<li><a href="#followers">Followers</a></li>
					<li><a href="#friends">Friends</a></li>
					<li><a href="#relevance">Relevance</a></li>
					<li><a href="#toplists">Top lists</a></li>
				</ul>
			</div>
			<div class="span9">
				<h1>Usage</h1>
				<h2 id="overview">Overview</h2>
				<p>
				<i>god</i> is a scalable, performant, persistent in memory data structure server. It allows massively distributed applications to update and fetch common data in a structured and sorted format.
				</p>
				<p>
				Its main inspirations are <a href="http://redis.io/">Redis</a> and <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord</a>/<a href="http://pdos.csail.mit.edu/papers/dhash:nsdi/paper.pdf">DHash</a>.
				Like <a href="http://redis.io/">Redis</a> it focuses on performance, ease of use and a small, simple yet powerful feature set, 
				while from the <a href="http://en.wikipedia.org/wiki/Chord_(peer-to-peer)">Chord</a>/<a href="http://pdos.csail.mit.edu/papers/dhash:nsdi/paper.pdf">DHash</a> projects it inherits scalability, redundancy and transparent failover behaviour.
				</p>
				<p>
				This is a usage instruction aiming to be somewhere between example collection and tutorial, targeting developers interested in trying out <i>god</i> as datastore. The example code snippets below are tested against somewhat current versions of Go and node, and should run as is if you provide them their dependencies and run a local <i>god</i> server.
				</p>
				<p>
				To try it out right now, <code>go get github.com/zond/god/god_server</code>, then run <code>god_server</code> and browse to <a href="http://localhost:9192/">http://localhost:9192/</a>.
				</p>
				<p>
				For API documentation, go to <a href="http://go.pkgdoc.org/github.com/zond/god">http://go.pkgdoc.org/github.com/zond/god</a>.
				</p>
				<p>
				For the source, go to <a href="https://github.com/zond/god">https://github.com/zond/god</a>.
				</p>
				<h2 id="operations">Operations</h2>
				<p>
				<i>god</i> is built to be simple to use, and as such has no dependencies for building apart from the Go standard library. For running, all you need is one statically linked binary.
				</p>
				<p>
				If you have a working <a href="http://golang.org/doc/install">Go</a> environment installed (specifically a writable <code>$GOPATH</code>), you just run <code>go get github.com/zond/god/god_server</code>. This will download, compile and install <i>god</i> and all its dependencies. After this you will find <code>god_server</code> in <code>$GOPATH/bin</code>. To start a server, just run <code>god_server -verbose=true</code>. Other option can be listed if you run <code>god_server -help</code>.
				</p>
				<p>
				Since there are a plethora of ways to daemonize such a program, and since Go doesn't currently contain its own way of doing it, daemonizing this binary is left to creative ops people out there.
				</p>
				<p>
				To make your server join an existing cluster/server, just run <code>god_server -joinIp HOST/IP</code>. It will default to using port 9191, but using the switch <code>-port</code> can force it to try another port.
				</p>
				<img class="illustration" src="web-gui.png"></object>
				<p>
				To make it easy to use, <i>god</i> always exports its interface on both Go <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> and HTTP/JSON. The HTTP/JSON interface is always exported on the next port after the main one where the <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> interface is exported. By default this is port 9192. If you started your server by running <code>god_server -verbose=true</code> as suggested above, you will find a small administrative/monitoring tool at <a href="http://localhost:9192">http://localhost:9192</a>.
				</p>
				<p>
				The server only listens to the default network interface for <code>localhost</code> by default. To make it listen to (and advertise itself to the cluster on) another network interface, use the switch <code>-ip HOST/IP</code>.
				</p>
				<h2 id="clients">Clients</h2>
				<p>
				As mentioned there are two APIs for <i>god</i>, <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> and HTTP/JSON.
				</p>
				<p>
				Using the <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> API is as simple as <code>go get github.com/zond/god/client</code>, and then <code>import "github.com/zond/god/client"</code>. See <a href="http://godoc.org/github.com/zond/god/client">http://godoc.org/github.com/zond/god/client</a> for godoc generated documentation.
				</p>
				<p>
				To simplify trying it out from the command line, there is also a command line interface available. To install it, run <code>go get github.com/zond/god/god_cli</code>, and then run <code>god_cli</code>. Documentation for the command format for this tool can be found at <a href="https://github.com/zond/god/tree/master/god_cli">https://github.com/zond/god/tree/master/god_cli</a>.
				</p>
				<p>
				Since the HTTP/JSON API is designed to be as simple as possible to interact with from any type of client system, there isn't really much to say about how to use it. Examples for the different commands found in the web monitor at <a href="http://localhost:9192">http://localhost:9192</a> (if the server is started via <code>god_server</code> with default options) along with the generated documentation at <a href="http://godoc.org/github.com/zond/god/client">http://godoc.org/github.com/zond/god/client</a> are likely the best way to learn and explore.
				</p>
				<p>
				The HTTP/JSON API is slightly less efficient than the <a href="http://golang.org/pkg/net/rpc/">net/rpc</a> API, mainly due to the receiving node having to figure out who is responsible for the operation in the request, something that the native Go client does on its own.
				</p>
				<h2 id="bytestorage">Storing bytes</h2>
				<p>
				The simplest and most obvious way to use <i>god</i> is to store bytes in it. Like all content in <i>god</i> nodes, the bytes you put in the system will be stored in RAM in one or more (if you have a cluster, which is really recommended) servers. To store byte arrays in the database, use the <b>put</b> command, either via <code>client.Conn#Put</code> or <code>POST /rpc/DHash.Put</code>.
				</p>
				<h2 id="users">Users</h2>
				<p>
				A trivial example would be to store application users in <i>god</i>. Here is a bit of example Go code that would store and fetch a user object:
				</p>
				<pre class="prettyprint">
{{.E "put_get.go"}}
				</pre>
				<p>
				And here is a bit of node compatible JavaScript doing the same thing against the HTTP/JSON API:
				</p>
				<pre class="prettyprint">
{{.E "put_get.js"}}
				</pre>
				<h2 id="structstorage">Storing structures</h2>
				<p>
				To experience the real power of <i>god</i>, one really has to use it to store data structures. The data structures in <i>god</i> are themselves key/value stores with unique keys and sorted on keys in byte order.
				</p>
				<p>
				Since they are stored not as serialized values under their keys, but as individual tree structures they can be used to store large amounts of data in a structured fashion, by using the keys of byte values and structures (tree values) to relate them to each other.
				</p>
				<p>
				To further make use of the efficient modification, sorting and lookup properties of these sub trees they can be both 'mirrored' to allow sorting on their values as well as keys and used in various set operations to analyze them in a more algorithmic fashion.
        </p>
				<h2 id="followers">Followers</h2>
				<p>
				The simplest way to store structured data in <i>god</i> is to just dump it into a sub tree as is. Here is a bit of example Go code that would modify and query the followers of a user:
				</p>
				<pre class="prettyprint">
{{.E "subput_slice.go"}}
				</pre>
				<p>
				And here is a bit of nody JavaScript doing the same thing against the HTTP/JSON API:
				</p>
				<pre class="prettyprint">
{{.E "subput_slice.js"}}
				</pre>
				<h2 id="friends">Friends</h2>
				<p>
				One simple way to use the set operation support in god would be to intersect followers and followees 
				</p>
				<h2 id="relevance">Relevance</h2>
				<p>
				Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
				</p>
				<h2 id="toplists">Top lists</h2>
				<p>
				Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
				</p>
			</div>
		</div>
	</body>
</html>
